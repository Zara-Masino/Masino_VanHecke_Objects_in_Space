<html>

<head>
    <title>Three.js Geometries Example</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="800"></canvas>

    <script type="x-shader/x-vertex" id="vertexShader">


        uniform float delta;
        uniform float alpha;
        out float rand;



        float random( vec2 p )
        {
            vec2 K1 = vec2(
                23.14069263277926, // e^pi (Gelfond's constant)
                 2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)
            );
            return fract( cos( dot(p,K1) ) * 12345.6789 );
        }

        void main() 
        {
            rand = random( vec2(2, 1) );
            // Can change the impact of delta here
            float displacement = delta * alpha;
            // The vertex displacement is simply the sine of delta
            vec3 p = position;
            p += displacement*p;
        
            gl_Position =  projectionMatrix * modelViewMatrix * vec4(p, 1.0);
        }

    </script>

    <script type="x-shader/x-vertex" id="fragShader">
in float rand;
 
void main()
{ 
    gl_FragColor = vec4(1.0, rand, 1.0-rand, 1.0);
}
    </script>

    <script type="module">

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';


        let mouseX = 0, mouseY = 0;

        // float rand = Math.random()*1;
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        var cameraPosition = new THREE.Vector3(300, 300, 300)
        camera.position.set(300, 300, 300);
        camera.lookAt(new THREE.Vector3(1.0, 1.0, 1.0));
        scene.add(camera);



        var renderer;
        const left = Math.floor(window.innerWidth * 0.0);
        const bottom = Math.floor(window.innerHeight * .05);
        const width = Math.floor(window.innerWidth * .7);
        const height = Math.floor(window.innerHeight * 1.0);
        
        let windowWidth, windowHeight;


        const views = [
            {

                //backwards
                left: 0.7,
                bottom: 0.0,
                width: 0.5,
                height: 1.0,
                leftWindow: Math.floor(window.innerWidth * 0.7),
                bottomWindow: Math.floor(window.innerHeight * 0.0),
                widthWindow: Math.floor(window.innerWidth * 0.5),
                heightWindow: Math.floor(window.innerHeight * 1.0),
                background: new THREE.Color(0.5, 0.5, 0.7),
                eye: [0, 300, 1800],
                up: [0, 1, 0],
                fov: 30,
                updateCamera: function (backCamera, scene, mouseX) {

                    backCamera.position.x += mouseX * 0.05;
                    backCamera.position.x = Math.max(Math.min(backCamera.position.x, 2000), - 2000);
                    backCamera.lookAt(scene.position);

                }
            },
            {
                //Frontward facing camera
                left: 0.0,
                bottom: 0.0,
                width: 0.7,
                height: 1.0,
                leftWindow: Math.floor(window.innerWidth * 0.0),
                bottomWindow: Math.floor(window.innerHeight * 0.05),
                widthWindow: Math.floor(window.innerWidth * 0.7),
                heightWindow: Math.floor(window.innerHeight * 1.0),
                background: new THREE.Color(0.7, 0.5, 0.5),
                eye: [0, 1800, 0],
                up: [0, 0, 1],
                fov: 45,
                updateCamera: function (camera, scene, mouseX) {

                    camera.position.x -= mouseX * 0.05;
                    camera.position.x = Math.max(Math.min(camera.position.x, 2000), - 2000);
                    camera.lookAt(camera.position.clone().setY(0));

                }
            }
        ];

        function initScene() {

            for (let ii = 0; ii < views.length; ++ii) {

                const view = views[ii];
                const camera = new THREE.PerspectiveCamera(view.fov, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.fromArray(view.eye);
                camera.up.fromArray(view.up);
                view.camera = camera;

            }
            renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
            renderer.setClearColor(0x000000);
            // If you want this to span the window, instead of using the myCanvas object, use the window object
            renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
            // If you want the render to span the window, uncomment this
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function updateSize() {

            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) {

                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;

                renderer.setSize(windowWidth, windowHeight);

            }

        }

        initScene();

        function render() {

            updateSize();

            for (let ii = 0; ii < views.length; ++ii) {

                const view = views[ii];
                const camera = view.camera;

                view.updateCamera(camera, scene, mouseX, mouseY);

                const left = Math.floor(windowWidth * view.left);
                const bottom = Math.floor(windowHeight * view.bottom);
                const width = Math.floor(windowWidth * view.width);
                const height = Math.floor(windowHeight * view.height);

                renderer.setViewport(left, bottom, width, height);
                renderer.setScissor(left, bottom, width, height);
                renderer.setScissorTest(true);
                renderer.setClearColor(view.background);

                camera.aspect = width / height;
                camera.updateProjectionMatrix();

                renderer.render(scene, camera);

            }

        }










        var movementSpeeds = 40;
        var totalObjects = 500;
        var objectSize = 10;
        var sizeRandomness = 4000;
        var colors = [0xFF0FFF, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF, 0xcbbeb5, 0x9003ff, 0x6d9bc3,
            0x87a96b, 0x520520, 0xeaa315, 0x327572, 0xb8888d, 0xcc77dd, 0xbcd4e6, 0xfe6f5e, 0x318ce7, 0xa2a2d0];
        /////////////////////////////////
        var dirs = [];
        var parts = [];

        var direction = new THREE.Vector3();
        let index;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();



        let objects = [];
        var xLookAt = 0;
        var yLookAt = 0;
        var zLookAt = 0;




        // renderer.setViewport(views[1].left, views[1].bottom, views[1].width, views[1].height);
        // renderer.setScissor(views[1].leftWindow, views[1].bottomWindow, views[1].widthWindow, views[1].heightWindow);
        // renderer.setScissorTest(true);



        // const backLeft = Math.floor(window.innerWidth * .7);
        // const backRight = Math.floor(window.innerHeight * 0.0);
        // const backWidth = Math.floor(window.innerWidth * .5);
        // const backHeight = Math.floor(window.innerHeight * 1.0);

        // var backCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        // var backCameraPosition = new THREE.Vector3(300, 300, 300)
        // backCamera.position.set(300, 300, 300);
        // backCamera.lookAt(new THREE.Vector3(-1.0, -1.0, -1.0));
        // scene.add(backCamera);


        // renderer.setViewport(views[0].left, views[0].right,  views[0].width,  views[0].height);
        // renderer.setScissor(views[0].leftWindow, views[0].bottomWindow, views[0].widthWindow, views[0].heightWindow);
        // renderer.setScissorTest(true);






        var controls = new PointerLockControls(camera, document.body);

        document.addEventListener('click', function () {
            controls.lock();
        });



        scene.add(controls.getObject());




        // The "ShaderMaterial" defines and calculates projectionMatrix, viewMatrix, and modelMatrix behind the scenes
        //   This means that you do not need to define them or alter them, but DO need to include them in your
        //   vertex shader.
        // If you want to do everything manually, you would use the RawShaderMaterial object
        // var customUniforms = {
        //     xPosition: {x: Math.random()*255},
        //     yPosition: {y: Math.random()*255}
        // };
        // var material = new THREE.ShaderMaterial({
        //     uniforms: customUniforms,
        //     vertexShader: document.getElementById("vertexShader").innerText,
        //     fragmentShader: document.getElementById("fragShader").innerText
        // });
        //var material = new THREE.MeshPhongMaterial({ color: 0x1562ff, emissive: 0x072534, flatShading: true });
        // }

        function random(type) {
            let randomNumber = Math.round(Math.random() * 10);
            if (type == 0) {
                if (randomNumber % 2 == 0) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                let array = [];
                for (let i = 0; i < type; i++) {
                    let newN = Math.round(Math.random() * 10);
                    array.push(newN);
                }
                return array;
            }
        }
        console.log(random(0));
        console.log(random(1));
        console.log(random(4));

        function makeMaterial() {
            if (random(1) > 8) {
                return shaderMaterials;
            }
            else {
                var material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
                return material;
            }
        }


        function movementSpeed(constant) {
            var speed = Math.random() * constant;
            if (random(0) == false) {
                speed *= -1;
            }
            return speed;
        }


        function Piece(shape) {
            this.rotateOnXAxis = random(0);
            if (this.rotateOnXAxis == true) {
                this.rotateXSpeed = movementSpeed(.12);
            }
            this.rotateOnYAxis = random(0);
            if (this.rotateOnYAxis == true) {
                this.rotateYSpeed = movementSpeed(.12);
            }
            this.verticalMovement = random(0);
            if (this.verticalMovement == true) {
                this.verticalSpeed = movementSpeed(.5);
            }
            this.horizontalMovement = random(0);
            if (this.horizontalMovement == true) {
                this.horizontalSpeed = movementSpeed(.5);
            }
            this.depthMovement = random(0);
            if (this.depthMovement == true) {
                this.depthSpeed = movementSpeed(.5);
            }

            // Set up the geometries
            this.create = function () {
                if (shape == true) {
                    let x, y, z;
                    if (random(1) > 7) {
                        let w = Math.random() * 50 + 5;
                        x = Math.random() * 20 + 5;
                        y = w;
                        z = w;
                    }
                    else {
                        x = Math.random() * 20 + 5;
                        y = Math.random() * 3 + 3;
                        z = Math.random() * 3 + 3;
                    }


                    var geometry = new THREE.SphereGeometry(x, y, z);
                    geometry.computeFaceNormals();
                    this.object = new THREE.Mesh(geometry, makeMaterial());
                }
                else if (shape == false) {

                    let x, y, z;
                    if (random(1) > 7) {
                        let w = Math.random() * 40 + 10;
                        x = w;
                        y = w;
                        z = w;
                    }
                    else {
                        x = Math.random() * 40 + 10;
                        y = Math.random() * 40 + 10;
                        z = Math.random() * 40 + 10;
                    }
                    let boxGeometry = new THREE.BoxGeometry(x, y, z);
                    this.object = new THREE.Mesh(boxGeometry, makeMaterial());
                }
                this.object.position.x = (Math.random() * (camera.position.x + 300) - (camera.position.x - 150)) + (camera.position.x - 150);
                this.object.position.y = (Math.random() * (camera.position.y + 150) - (camera.position.y - 50)) + (camera.position.y - 50);
                this.object.position.z = (Math.random() * (camera.position.z + 150) - (camera.position.z + 50)) + (camera.position.z + 50);
                this.object.geometry.computeBoundingSphere();
                scene.add(this.object);
            }

        }

        function initObjects(x) {
            for (let i = 0; i < x; i++) {
                let shape = new Piece(random(0));
                objects.push(shape);
                shape.create();
                if (shape.object.material == shaderMaterials) {
                    index = i;
                }
            }
        }

        console.log("objects ", objects);



        function makeCoord(max, min) {
            let randomNumber = (Math.random() * max) + min;
            if (random(0) == true) {
                randomNumber *= -1;
            }
            return randomNumber;
        }

        function relocateShape(shape) {

            let x = makeCoord(200, 10);
            let y = makeCoord(100, 10);
            let z = makeCoord(200, 10);

            shape.object.position.x = cameraPosition.x + (x);
            shape.object.position.y = cameraPosition.y + (y);
            shape.object.position.z = cameraPosition.z + (z);


            //console.log("increments of relocation ", x, y, z)

        }


        function calcDistance(point, shape) {
            const distance = Math.sqrt(
                (point.x - shape.object.position.x) * (point.x - shape.object.position.x) +
                (point.y - shape.object.position.y) * (point.y - shape.object.position.y) +
                (point.z - shape.object.position.z) * (point.z - shape.object.position.z)
            )
            return distance;
        }


        function tooFar(point, shape) {
            let distance = calcDistance(point, shape);
            if (distance > 300) {
                //console.log("too far!");
                relocateShape(shape);
            };

        }


        function collisionDetection(point, shape) {
            let distance = calcDistance(point, shape);
            if (distance < shape.object.geometry.boundingSphere.radius) {
                //  console.log("collided");
                parts.push(new ExplodeAnimation(shape.object.position.x, shape.object.position.y, shape.object.position.z));
                relocateShape(shape);
            }

            // we are using multiplications because is faster than calling Math.pow
        }



        var customUniforms = {
            delta: { value: 0 },
            alpha: { value: Math.random() * 1 }
        };

        var shaderMaterials = new THREE.ShaderMaterial({
            uniforms: customUniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragShader').textContent
        });

        var tdelta = 0;

        function executeMovements() {
            for (let i = 0; i < objects.length; i++) {
                //console.log("object", objects[i]);
                if (objects[i].rotateOnYAxis == true) {
                    if (random(0) == true) {
                        objects[i].object.rotateY(objects[i].rotateYSpeed);
                    }
                }
                if (objects[i].rotateOnXAxis == true) {
                    if (random(0) == true) {
                        objects[i].object.rotateX(objects[i].rotateXSpeed);
                    }
                }
                if (objects[i].verticalMovement == true) {
                    if (random(0) == true) {
                        objects[i].object.translateY(objects[i].verticalSpeed);
                    }
                }
                if (objects[i].horizontalMovement == true) {
                    if (random(0) == true) {
                        objects[i].object.translateX(objects[i].horizontalSpeed);
                    }
                }
                if (objects[i].depthMovement == true) {
                    if (random(0) == true) {
                        objects[i].object.translateZ(objects[i].depthSpeed);
                    }
                }
            }
        }



        function ExplodeAnimation(x, y, z) {
            // console.log("made it in explode");
            var geometry = new THREE.Geometry();
            var sphereGeom = new THREE.SphereGeometry();

            for (let i = 0; i < totalObjects; i++) {
                var vertex = new THREE.Vector3();
                vertex.x = x;
                vertex.y = y;
                vertex.z = z;

                geometry.vertices.push(vertex);
                dirs.push({ x: (Math.random() * movementSpeeds) - (movementSpeeds / 2), y: (Math.random() * movementSpeeds) - (movementSpeeds / 2), z: (Math.random() * movementSpeeds) - (movementSpeeds / 2) });
            }

            var colorsRand = Math.round(Math.random() * 17)
            console.log('random color', colorsRand);
            var material = new THREE.PointsMaterial({ size: objectSize, color: colors[colorsRand] });
            var particles = new THREE.Points(geometry, material);

            this.object = particles;
            this.status = true;

            this.xDir = (Math.random() * movementSpeeds) - (movementSpeeds / 2);
            this.yDir = (Math.random() * movementSpeeds) - (movementSpeeds / 2);
            this.zDir = (Math.random() * movementSpeeds) - (movementSpeeds / 2);

            scene.add(this.object);

            this.update = function () {
                if (this.status == true) {
                    var pCount = totalObjects;
                    while (pCount--) {
                        var particle = this.object.geometry.vertices[pCount]
                        particle.y += dirs[pCount].y;
                        particle.x += dirs[pCount].x;
                        particle.z += dirs[pCount].z;
                    }
                    this.object.geometry.verticesNeedUpdate = true;
                }
            }

        }


        // var tshape = new Piece(random(0));
        // objects.push(tshape);
        // tshape.create();


        function animate() {

            render();

            // for (let ii = 0; ii < views.length; ++ii) {

            //     const view = views[ii];
            //     const camera = view.camera;

            //     view.updateCamera(camera, scene, mouseX, mouseY);

            //     const left = Math.floor(windowWidth * view.left);
            //     const bottom = Math.floor(windowHeight * view.bottom);
            //     const width = Math.floor(windowWidth * view.width);
            //     const height = Math.floor(windowHeight * view.height);

            //     renderer.setViewport(left, bottom, width, height);
            //     renderer.setScissor(left, bottom, width, height);
            //     renderer.setScissorTest(true);
            //     renderer.setClearColor(view.background);

            //     camera.aspect = width / height;
            //     camera.updateProjectionMatrix();

            //     renderer.render(scene, camera);

            // }

                

            camera.getWorldDirection(direction);

            var pCount = parts.length;
            while (pCount--) {
                parts[pCount].update();
            }

            executeMovements();
            for (let i = 0; i < objects.length; i++) {
                collisionDetection(cameraPosition, objects[i]);
                tooFar(cameraPosition, objects[i]);
            }


            tdelta += 0.03;
            // Update the uniform value for delta
            // sphere.material.uniforms.delta.value = Math.sin(tdelta);
            objects[index].object.material.uniforms.delta.value = Math.sin(tdelta);

            requestAnimationFrame(animate);


            if (controls.isLocked === true) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                // console.log("delta ", delta);
                // console.log("direction before math ", direction);
                // console.log("both ", direction * delta);
                //CAMERA MOVES HERE
                var speed = 45;
                direction.x *= delta * speed;
                direction.y *= delta * speed;
                direction.z *= delta * speed;
                // console.log("direction after math ", direction)
                // console.log("camera position before ", camera.position);
                camera.position.add(direction);
                // console.log("camera position after ", camera.position);
                //console.log(controls);
                for (let i = 0; i < objects.length; i++) {
                    collisionDetection(cameraPosition, objects[i]);
                    tooFar(cameraPosition, objects[i]);
                }

                cameraPosition.x = camera.position.x;
                cameraPosition.y = camera.position.y;
                cameraPosition.z = camera.position.z;

                // console.log("camera ", cameraPosition.x, cameraPosition.y, cameraPosition.z);

                prevTime = time;

                // controls.moveRight(- velocity.x * delta);
                // controls.moveForward(- velocity.z * delta);
                // controls.getObject().position.y += (velocity.y * delta); // new behavior
            }


            renderer.render(scene, camera);
            // renderer.render(scene, backCamera);
            //renderer.render(scene, backCamera);
        }


        //TEST SPHERE
        // var geometry = new THREE.SphereGeometry(50, 10, 25);
        // geometry.computeFaceNormals();
        // var sphere = new THREE.Mesh(geometry, shaderMaterials);
        // //sphere.color = [0,0,1];
        // sphere.position.x = 200;
        // sphere.position.y = 200;
        // sphere.position.z = 200;
        // //sphere.material.uniforms.xPosition.x = .5 +Math.sin(100)*.5;
        // sphere.geometry.computeBoundingSphere();
        // //objects.push(sphere);
        // console.log('HELO?', sphere);
        // scene.add(sphere);






        window.addEventListener('mousedown', onclick, false);
        // window.addEventListener('resize', onWindowResize, false);

        function onclick() {
            console.log("clicked");
            event.preventDefault();
            parts.push(new ExplodeAnimation(0, 0, 0));
        }


        //Make and place objects
        initObjects(100);

        animate();

        parts.push(new ExplodeAnimation(0, 0));
        //render();







    </script>
</body>

</html>