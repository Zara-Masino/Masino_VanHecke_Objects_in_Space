<html>

<head>
    <title>Three.js Geometries Example</title>
</head>

<body>

    <canvas id="myCanvas" width="800" height="800"></canvas>

    <script type="x-shader/x-vertex" id="vertexShader">

      
        uniform float delta;
        uniform float alpha;

        void main() 
        {
            // Can change the impact of delta here
            float displacement = delta * alpha;
            // The vertex displacement is simply the sine of delta
            vec3 p = position;
            p += displacement*p;
        
            gl_Position =  projectionMatrix * modelViewMatrix * vec4(p, 1.0);

              
        }

    </script>

    <script type="x-shader/x-vertex" id="fragShader">
in float rand;
 
void main()
{ 
    gl_FragColor = vec4(1.0, rand, 1.0-rand, 1.0);
}
    </script>

    <script type="module">

        let objects = [];

        var xLookAt = 0;
        var yLookAt = 0;
        var zLookAt = 0;
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        

        // float rand = Math.random()*1;
        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        var cameraPosition = new THREE.Vector3(300, 300, 300)
        camera.position.set(300, 300, 300);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        // If you want the render to span the window, uncomment this
        renderer.setSize(window.innerWidth, window.innerHeight);



        // The "ShaderMaterial" defines and calculates projectionMatrix, viewMatrix, and modelMatrix behind the scenes
        //   This means that you do not need to define them or alter them, but DO need to include them in your
        //   vertex shader.
        // If you want to do everything manually, you would use the RawShaderMaterial object
        // var customUniforms = {
        //     xPosition: {x: Math.random()*255},
        //     yPosition: {y: Math.random()*255}
        // };
        // var material = new THREE.ShaderMaterial({
        //     uniforms: customUniforms,
        //     vertexShader: document.getElementById("vertexShader").innerText,
        //     fragmentShader: document.getElementById("fragShader").innerText
        // });
        //var material = new THREE.MeshPhongMaterial({ color: 0x1562ff, emissive: 0x072534, flatShading: true });
        // }

        function random(type) {
            let randomNumber = Math.round(Math.random() * 10);
            if (type == 0) {
                if (randomNumber % 2 == 0) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                let array = [];
                for (let i = 0; i < type; i++) {
                    let newN = Math.round(Math.random() * 10);
                    array.push(newN);
                }
                return array;
            }
        }


        console.log(random(0));
        console.log(random(1));
        console.log(random(4));



        function Sphere() {
            this.rotateOnXAxis = random(0);
            if (this.rotateOnXAxis == true) {
                this.rotateXSpeed = Math.random() * .12;
                if (random(0) == false) {
                    this.rotateXSpeed *= -1;
                }
            }

            this.rotateOnYAxis = random(0);
            if (this.rotateOnYAxis == true) {
                this.rotateYSpeed = Math.random() * .12;
                if (random(0) == false) {
                    this.rotateYSpeed *= -1;
                }
            }

            this.verticalMovement = random(0);
            if (this.verticalMovement == true) {
                this.verticalSpeed = Math.random() * .5;
                if (random(0) == false) {
                    this.verticalSpeed *= -1;
                }
            }
            this.horizontalMovement = random(0);
            if (this.horizontalMovement == true) {
                this.horizontalSpeed = Math.random() * .5;
                if (random(0) == false) {
                    this.verticalSpeed *= -1;
                }
            }

            this.depthMovement = random(0);
            if (this.depthMovement == true) {
                this.depthSpeed = Math.random() * .5;
                if (random(0) == false) {
                    this.depthSpeed *= -1;
                }
            }

            // Set up the geometries

            this.create = function () {
                let x,y,z;
                if (random(1) > 7) {
                    let w = Math.random()*50 +5;
                    x = Math.random()*20+5;
                    y = w;
                    z = w;
                }
                else {
                    x = Math.random()*20 +5;
                    y = Math.random()*3 +3;
                    z = Math.random()*3 +3;
                }


                var geometry = new THREE.SphereGeometry(x, y, z);
                geometry.computeFaceNormals();
                this.object = new THREE.Mesh(geometry, makeMaterial());
                this.object.position.x = (Math.random() * (camera.position.x + 300) - (camera.position.x - 150)) + (camera.position.x - 150);
                this.object.position.y = (Math.random() * (camera.position.y + 150) - (camera.position.y - 50)) + (camera.position.y - 50);
                this.object.position.z = (Math.random() * (camera.position.z + 150) - (camera.position.z + 50)) + (camera.position.z + 50);
                //sphere.material.uniforms.xPosition.x = .5 +Math.sin(100)*.5;
                this.object.geometry.computeBoundingSphere();
                scene.add(this.object);
            }

        }

        function Cube() {
            this.rotateOnXAxis = random(0);
            if (this.rotateOnXAxis == true) {
                this.rotateXSpeed = Math.random() * .12;
                if (random(0) == false) {
                    this.rotateXSpeed *= -1;
                }
            }

            this.rotateOnYAxis = random(0);
            if (this.rotateOnYAxis == true) {
                this.rotateYSpeed = Math.random() * .12;
                if (random(0) == false) {
                    this.rotateYSpeed *= -1;
                }
            }

            this.verticalMovement = random(0);
            if (this.verticalMovement == true) {
                this.verticalSpeed = Math.random() * .5;
                if (random(0) == false) {
                    this.verticalSpeed *= -1;
                }
            }
            this.horizontalMovement = random(0);
            if (this.horizontalMovement == true) {
                this.horizontalSpeed = Math.random() * .5;
                if (random(0) == false) {
                    this.verticalSpeed *= -1;
                }
            }

            this.depthMovement = random(0);
            if (this.depthMovement == true) {
                this.depthSpeed = Math.random() * .5;
                if (random(0) == false) {
                    this.depthSpeed *= -1;
                }
            }



            this.create = function () {
                let x,y,z;
                if (random(1) > 7) {
                    let w = Math.random()*40 +10;
                    x = w;
                    y = w;
                    z = w;
                }
                else {
                    x = Math.random()*40 +10;
                    y = Math.random()*40 +10;
                    z = Math.random()*40 +10;
                }
                let boxGeometry = new THREE.BoxGeometry(x, y, z);
                // let boxMaterial = new THREE.MeshBasicMaterial({ color: 0xf00fff });
                // let boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
                // for (let i = 0; i < 1; i++) {
                this.object = new THREE.Mesh(boxGeometry, makeMaterial());
                this.object.position.x = (Math.random() * (camera.position.x + 300) - (camera.position.x - 150)) + (camera.position.x - 150);
                this.object.position.y = (Math.random() * (camera.position.y + 150) - (camera.position.y - 50)) + (camera.position.y - 50);
                this.object.position.z = (Math.random() * (camera.position.z + 150) - (camera.position.z + 50)) + (camera.position.z + 50);
                this.object.geometry.computeBoundingSphere();
                scene.add(this.object);

            }

        }

        function makeMaterial() {
            if (random(1) > 8) {
                return shaderMaterials;
            } 
            else {
                var material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
                 return material;
            }
        }


        var customUniforms = {
            delta: { value: 0 },
            alpha: {value: Math.random()*1}
        };
        
        var shaderMaterials = new THREE.ShaderMaterial({
            uniforms: customUniforms,
            vertexShader: document.getElementById('vertexShader').textContent
        });


        var geometry = new THREE.SphereGeometry(50, 10, 25);
        geometry.computeFaceNormals();
        var sphere = new THREE.Mesh(geometry, shaderMaterials);
        //sphere.color = [0,0,1];
        sphere.position.x = 200;
        sphere.position.y = 200;
        sphere.position.z = 200;


        //sphere.material.uniforms.xPosition.x = .5 +Math.sin(100)*.5;
        sphere.geometry.computeBoundingSphere();
        //objects.push(sphere);
        console.log('HELO?', sphere);

        scene.add(sphere);



        for (let i = 0; i < 30; i++) {
            let sphere = new Sphere();
            let cube = new Cube();
            objects.push(sphere);
            objects.push(cube);
            sphere.create();
            cube.create();
            // console.log(objects[i]);
        }


        console.log(objects);

        // objectArray[i].geometry.boundingSphere.radius
        // objectArray[i].geometry.boundingSphere.center.x
        // objectArray[i].position.x
        function isPointInsideSphere(point, shape) {
            // console.log("SHAPE???????????? " , shape.object);
            const distance = Math.sqrt(
                (point.x - shape.object.position.x) * (point.x - shape.object.position.x) +
                (point.y - shape.object.position.y) * (point.y - shape.object.position.y) +
                (point.z - shape.object.position.z) * (point.z - shape.object.position.z)
            )

            if(distance > 350){
                console.log("too far!");
                shape.object.position.x = (Math.random() * (camera.position.x + 300) - (camera.position.x - 150)) + (camera.position.x - 150);
                shape.object.position.y = (Math.random() * (camera.position.y + 150) - (camera.position.y - 50)) + (camera.position.y - 50);
                shape.object.position.z = (Math.random() * (camera.position.z + 150) - (camera.position.z + 50)) + (camera.position.z + 50);
            };

            return distance < shape.object.geometry.boundingSphere.radius;
            // we are using multiplications because is faster than calling Math.pow
        }

        


        var delta = 0;
        function render() {
            //sphere.rotateY(0.1);
            //sphere.material.uniforms.xPosition.x = .5 +Math.sin(100)*.5;
            // customUniforms.x=Math.random()*1;


            delta += 0.03;

            // Update the uniform value for delta
            sphere.material.uniforms.delta.value = Math.sin(delta);

            requestAnimationFrame(render); // call it again!
            renderer.render(scene, camera);
        }




        function keyHandler(e) {
            switch (e.keyCode) {
                case 83: // The 'S' key
                    yLookAt -= 50;
                    break;
                case 68: // The 'D' key
                    xLookAt += 50;
                    break;
                case 65: // The 'A' keysadwadasdadwawdawd
                    xLookAt -= 50;
                    break;
                case 87: // The 'W' key
                    yLookAt += 50;
                    break;
                case 38: // The 'up arrow' key
                    camera.position.y += 50;
                    cameraPosition.y += 50;
                    break;
                case 40: // The 'down arrow' key
                    camera.position.y -= 50;
                    cameraPosition.y -= 50;
                    break;

                case 37: // The 'left arrow' key
                    camera.position.x -= 50;
                    cameraPosition.x -= 50;
                    break;

                case 39: // The 'right arrow' key
                    camera.position.x += 50;
                    cameraPosition.x += 50;
                    break;

                case 90: // The 'z arrow' key
                    camera.position.z += 50;
                    cameraPosition.z += 50;
                    break;
                case 88: // The 'down arrow' key
                    camera.position.z -= 50;
                    cameraPosition.z -= 50;
                    break;
            }

        }
        document.addEventListener("keydown", keyHandler, false);



        function animate() {
            for (let i = 0; i < objects.length; i++) {
                if (objects[i].rotateOnYAxis == true) {
                    if (random(0) == true) {
                        objects[i].object.rotateY(objects[i].rotateYSpeed);
                    }
                }
                if (objects[i].rotateOnXAxis == true) {
                    if (random(0) == true) {
                        objects[i].object.rotateX(objects[i].rotateXSpeed);
                    }
                }
                //console.log("object", objects[i]);
                var collide = isPointInsideSphere(cameraPosition, objects[i]);
                if (collide == true) {
                    //do something with collision
                }

                if (objects[i].verticalMovement == true) {
                    if (random(0) == true) {
                        objects[i].object.translateY(objects[i].verticalSpeed);
                    }
                }
                if (objects[i].horizontalMovement == true) {
                    if (random(0) == true) {
                        objects[i].object.translateX(objects[i].horizontalSpeed);
                    }
               }
               if (objects[i].depthMovement == true) {
                    if (random(0) == true) {
                        objects[i].object.translateZ(objects[i].depthSpeed);
                    }
               }


            }

            camera.lookAt(new THREE.Vector3(xLookAt, yLookAt, zLookAt));

            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        render();
    </script>
</body>

</html>