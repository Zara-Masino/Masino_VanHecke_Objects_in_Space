Blog on camera 
https://blogs.perficient.com/2020/05/21/3d-camera-movement-in-three-js-i-learned-the-hard-way-so-you-dont-have-to/

Camera movement with mouse (I found this on phone so I’m not sure if it will actually works) ->
https://codepen.io/misterkidult/pen/dybgapB


Object pool -> https://codepen.io/sebastianlenton/pen/QWLQGPp

Particle explosion -> 
https://codepen.io/Xanmia/pen/nqyMgJ

Shred object into particles ->
https://github.com/Jam3/jam3-lesson-webgl-shader-threejs#step-4-exploding-triangles


Idea
To see how many objects you’ve passed
Keep iterating through for loop of group of objects 
If the cameras x y or z position is greater than a specific objects x y or z position in the array then increment the number of boxes you’ve passed. Otherwise decrement 
After the number of objects you have passed reached a certain number, move yourself to the thr very starting position. 

Look behind with camera ->
https://github.com/Jam3/jam3-lesson-webgl-shader-threejs#step-4-exploding-triangles

Calculate where the camera is looking and where the atarget is 
https://stackoverflow.com/questions/14813902/three-js-get-the-direction-in-which-the-camera-is-looking


No clue what this is but
https://bitcoden.com/answers/rotate-camera-in-threejs-with-mouse

https://stackoverflow.com/questions/8426822/rotate-camera-in-three-js-with-mouse

Mouse movement for camera ->
https://discourse.threejs.org/t/mouse-movement-to-move-camera/25643/2

Actually seems like a helpful example for moving camera in direction of the mouse ->
https://jsfiddle.net/f2Lommf5/14006/









Move sphere based on delta code -------------------------------------------------------------------------->
<html>
<head>
    <title>CSC 3210 Practice 4.7</title>
</head>
<body>

    <canvas id="myCanvas" width="1000" height="1000"></canvas>

    <script type="x-shader/x-vertex" id="vertexShader">
uniform float delta;

void main() 
{
    // Can change the impact of delta here
    float displacement = delta * .1;
    // The vertex displacement is simply the sine of delta
    vec3 p = position;
    p += displacement*p;

    gl_Position =  vec4(p, 1.0);
}
	</script>


    <script type="module">
import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";

// In Three.js, shaders are applied to meshes just like colors, 
//   through the use of materials
var customUniforms = {
    delta: {value: 0}
};
var material = new THREE.ShaderMaterial({
    uniforms: customUniforms,
    vertexShader: document.getElementById('vertexShader').textContent
});


// Set up the scene
var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 500 );
camera.position.z = 35;
camera.lookAt( new THREE.Vector3(0.0,0.0,0.0) );
scene.add( camera );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
renderer.setClearColor(0x000000);
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);

// Create a second object whose shading will be the same as the box
var geometry = new THREE.SphereBufferGeometry( .50, 32, 32 );
var mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );

// Create the animation by producing a "render loop"
render();
var delta = 0;
function render() {
    // The delta changes with the frames
    //   Adjust this to adjust the speed
    delta += 0.03;

    // Update the uniform value for delta
    mesh.material.uniforms.delta.value = Math.sin(delta);

    // Render the scene as normal
    renderer.render(scene, camera);
    requestAnimationFrame(render); // call it again!
}
    </script>
</body>
</html>
















Rotate around x axis and itself --------------------------------------------------------------------------->
<html>
<head>
    <title>Three.js Transformation About an Axis Example</title>
</head>
<body>
 
    <canvas id="myCanvas" width="800" height="800"></canvas>
 
    <script type="module">
import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
 
 
// From https://stackoverflow.com/questions/26660395/rotation-around-an-axis-three-js
// In order to rotate about an axis, you must construct the rotation matrix (which will rotate about the axis by default)
// Note: You can also use Quaternions or Euler angles, which you may see if you search online
//    That is beyond what I'd like to go over in this course, but feel free to experiment
function rotateAboutWorldAxis(object, axis, angle) {
  var rotationMatrix = new THREE.Matrix4();
  rotationMatrix.makeRotationAxis( axis.normalize(), angle );
  var currentPos = new THREE.Vector4(object.position.x, object.position.y, object.position.z, 1);
  var newPos = currentPos.applyMatrix4(rotationMatrix);
  object.position.x = newPos.x;
  object.position.y = newPos.y;
  object.position.z = newPos.z;
}
 
 
// Have a few variables to control the camera
var xLookAt = 0;
var yLookAt = 0;
var zLookAt = 0;
var turnSpeed = 0.4;
var animateRotation = false;
var animateOtherRotation = false;
var cameraRotation = 0.0;
 
var scene = new THREE.Scene();
 
var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 15;  // Try moving this around!
camera.lookAt( new THREE.Vector3(xLookAt,yLookAt,zLookAt));
scene.add( camera );
 
var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true, depth: true});
renderer.setClearColor(0x000000);
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);
 
 
// Add another sphere
var sphereTranslation = 2.0;
var boxTranslation = 3.0;
var geometry = new THREE.SphereGeometry( 2, 32, 32 );
geometry.computeFaceNormals();
var material = new THREE.MeshPhongMaterial( { color: 0x156289, emissive: 0x072534, flatShading: true } );;
var sphere = new THREE.Mesh( geometry, material );
sphere.position.set( sphereTranslation, 0.0, 0.0 );
scene.add( sphere );
 
// Lights will be covered in Unit 7
var lights = [];
lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 0 ].position.set( 0, 200, 0 );
lights[ 1 ].position.set( 100, 200, 100 );
lights[ 2 ].position.set( - 100, - 200, - 100 );
scene.add( lights[ 0 ] );
scene.add( lights[ 1 ] );
scene.add( lights[ 2 ] );
 
 
var count = 0
// Use this for not-necessarily-static scenes or scenes you want to animate
function animate() {
 
  // We need to translate the object back to the origin before rotating it:
  rotateAboutWorldAxis( sphere, new THREE.Vector3(0.0, 1.0, 0.0), turnSpeed*0.1);
  // Rotate while we rotate:
  sphere.geometry.rotateZ(turnSpeed*0.1);
 
  // If we're rotating the camera change that here.
  if( animateRotation )
    // The applyAxisAngle method rotates about an axis in space
    camera.position.applyAxisAngle( new THREE.Vector3(0.0, 1.0, 0.0 ), turnSpeed * 0.1 );
  if( animateOtherRotation )
    camera.position.applyAxisAngle( new THREE.Vector3(0.0, 0.0, 1.0 ), turnSpeed * 0.1 );
 
  camera.lookAt( new THREE.Vector3(xLookAt,yLookAt,zLookAt) );
 
  requestAnimationFrame( animate );
  renderer.render( scene, camera );
}
animate();
 
function toggleRotation() {
  animateRotation = !animateRotation;
}
function toggleOtherRotation() {
  animateOtherRotation = !animateOtherRotation;
}
 
// Simple way to setup keybaord controls:
function keyHandler(e) {
  switch(e.keyCode){
    case 83: // The 'S' key
      yLookAt -= turnSpeed;
    break;
    case 68: // The 'D' key
      xLookAt += turnSpeed;
    break;
    case 65: // The 'A' key
      xLookAt -= turnSpeed;
    break;
    case 87: // The 'W' key
      yLookAt += turnSpeed;
    break;
    case 84: // The 'T' key
      toggleRotation();
    break;
    case 82: // The 'R' key
      toggleOtherRotation();
    break;
  }
}
document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>























Sphere (already have info) and square make bigger and smaller code --------------------------------------->
<html>
<head>
    <title>Three.js Transformations Example</title>
</head>
<body>
 
    <canvas id="myCanvas" width="800" height="800"></canvas>
 
    <script type="module">
import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
 
// Have a few variables to control the camera
var xLookAt = 0;
var yLookAt = 0;
var zLookAt = 0;
var turnSpeed = 0.4;
var animateRotation = false;
var animateOtherRotation = false;
var cameraRotation = 0.0;
 
var scene = new THREE.Scene();
 
var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.z = 15;  // Try moving this around!
camera.lookAt( new THREE.Vector3(xLookAt,yLookAt,zLookAt));
scene.add( camera );
 
var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true, depth: true});
renderer.setClearColor(0x000000);
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);
 
 
// Add another sphere
var sphereTranslation = 2.0;
var boxTranslation = 3.0;
var geometry = new THREE.SphereGeometry( 2, 32, 32 );
geometry.computeFaceNormals();
 
var boxGeometry = new THREE.BoxGeometry(1,1,1);
boxGeometry.computeFaceNormals();
 
var material = new THREE.MeshPhongMaterial( { color: 0x156289, emissive: 0x072534, flatShading: true } );;
var sphere = new THREE.Mesh( geometry, material );
sphere.position.set( sphereTranslation, 0.0, 0.0 );
scene.add( sphere );
 
var box = new THREE.Mesh(boxGeometry, material );
box.position.set(0.0, boxTranslation, 0.0);
scene.add( box );
 
// Lights will be covered in Unit 7
var lights = [];
lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
lights[ 0 ].position.set( 0, 200, 0 );
lights[ 1 ].position.set( 100, 200, 100 );
lights[ 2 ].position.set( - 100, - 200, - 100 );
scene.add( lights[ 0 ] );
scene.add( lights[ 1 ] );
scene.add( lights[ 2 ] );
 
 
var count = 0
// Use this for not-necessarily-static scenes or scenes you want to animate
function animate() {
  // This doesn't work because we are not applying the transformation to the sphere every frame
  //sphere.geometry.translate(-sphereTranslation,0.0,0.0);
  // sphere.geometry.rotateZ(turnSpeed*0.1);
  //sphere.geometry.translate(sphereTranslation,0.0,0.0);
 
  // We need to translate the object back to the origin before rotating it:
  sphere.geometry.rotateZ(turnSpeed*0.1);
  //sphere.rotation.set( 0.0, 0.0, turnSpeed*0.1);
 
  // Make the box scale with the sin wave
  var scaleValue = 0.1 * Math.sin(count++);
  box.scale.set(1 + scaleValue, 1 + scaleValue, 1 + scaleValue);
  if(count > 1000000){
    count = 0;
  }
 
  // If we're rotating the camera change that here.
  if( animateRotation )
    // The applyAxisAngle method rotates about an axis in space
    camera.position.applyAxisAngle( new THREE.Vector3(0.0, 1.0, 0.0 ), turnSpeed * 0.1 );
  if( animateOtherRotation )
    camera.position.applyAxisAngle( new THREE.Vector3(0.0, 0.0, 1.0 ), turnSpeed * 0.1 );
 
  camera.lookAt( new THREE.Vector3(xLookAt,yLookAt,zLookAt) );
 
  requestAnimationFrame( animate );
  renderer.render( scene, camera );
}
animate();
 
function toggleRotation() {
  animateRotation = !animateRotation;
}
function toggleOtherRotation() {
  animateOtherRotation = !animateOtherRotation;
}
 
// Simple way to setup keybaord controls:
function keyHandler(e) {
  switch(e.keyCode){
    case 83: // The 'S' key
      yLookAt -= turnSpeed;
    break;
    case 68: // The 'D' key
      xLookAt += turnSpeed;
    break;
    case 65: // The 'A' key
      xLookAt -= turnSpeed;
    break;
    case 87: // The 'W' key
      yLookAt += turnSpeed;
    break;
    case 84: // The 'T' key
      toggleRotation();
    break;
    case 82: // The 'R' key
      toggleOtherRotation();
    break;
  }
}
document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>















Vertex shader to make pretty spinny ball have many colors ----------------------------------------------->
<html>
 
<head>
    <title>Three.js Geometries Example</title>
</head>
 
<body>
 
    <canvas id="myCanvas" width="800" height="800"></canvas>
 
    <script type="x-shader/x-vertex" id="vertexShader">
out float rand;  // Pass to the fragment shader
 
// Used to get random numbers
// Found here https://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader
float random( vec2 p )
{
    vec2 K1 = vec2(
        23.14069263277926, // e^pi (Gelfond's constant)
         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)
    );
    return fract( cos( dot(p,K1) ) * 12345.6789 );
}
 
void main()
{
    // Grab a random number based on the position of the vertex
    rand = random( vec2( position.x, position.y ) );
 
    // You need the "projectionMatrix * viewMatrix * modelMatrix" which is part of ShaderMaterial
    gl_Position =  projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
    // Uncomment this and watch it DISAPPEAR
//    gl_Position = vec4( position, 1.0 );
}
    </script>
 
    <script type="x-shader/x-vertex" id="fragShader">
in float rand;
 
void main()
{
   
    gl_FragColor = vec4(1.0, rand, 1.0-rand, 1.0);
}
    </script>
 
    <script type="module">
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
 
        var scene = new THREE.Scene();
 
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.z = 50;
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);
 
        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        // If you want the render to span the window, uncomment this
        renderer.setSize(window.innerWidth, window.innerHeight);
 
        // Set up the geometries
        var geometry = new THREE.SphereGeometry(15, 32, 32);
        geometry.computeFaceNormals();
 
        // The "ShaderMaterial" defines and calculates projectionMatrix, viewMatrix, and modelMatrix behind the scenes
        //   This means that you do not need to define them or alter them, but DO need to include them in your
        //   vertex shader.
        // If you want to do everything manually, you would use the RawShaderMaterial object
        var uniforms
        var material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById("vertexShader").innerText,
            fragmentShader: document.getElementById("fragShader").innerText
        });
        //var material = new THREE.MeshPhongMaterial( { color: 0x1562ff, emissive: 0x072534, flatShading: true } );
        var sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);
 
        function render() {
            sphere.rotateY(0.1);
 
            requestAnimationFrame(render); // call it again!
            renderer.render(scene, camera);
        }
 
        render();
    </script>
</body>

</html>







Change colors of geometries ->
http://cs.merrimack.edu/~stuetzlec/CourseExamples/CSC5210_ThreeJSWithAdvancedShaders/





Scissor box potentially ->
http://cs.merrimack.edu/~stuetzlec/CourseExamples/CSC5210_Practice5-4/





